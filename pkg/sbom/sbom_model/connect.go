package sbommodel

import "fmt"

// GeneratePackages generates a graph of SbomPackage from the information containing references to dependencies.
// As the dependency information was generated by the SBOM tool and inserted into the same source
// SBOM file, this will only match a dependency if ALL the identifiers for a dependency match for
// the same identifiers in the referenced package.  Note that the dependency identifiers may be
// a subset of the identifiers in the referenced package.
// Returns (packages, roots, error)
func GeneratePackages(
	tree []*SbomPackageDependencies,
) (all []*SbomPackage, roots []*SbomPackage, err error) {
	// First pass: build a matchable list of packages.
	pkgs := make([]genPkg, len(tree))
	all = make([]*SbomPackage, len(tree))
	err = nil
	isParented := make([]bool, len(tree))

	for idx, pkg := range tree {
		id := NewMatchableId(pkg.Identifiers)
		res := &SbomPackage{
			SbomPackageInfo: pkg.SbomPackageInfo,
			Parents:         []*SbomPackage{},
			Dependencies:    []*SbomPackage{},
		}
		pkgs[idx] = genPkg{
			info: pkg,
			id:   id,
			res:  res,
		}
		all[idx] = res

		// Duplicate work, as it should default to false, but being explicit.
		isParented[idx] = false
	}

	// Second pass: resolve dependencies.
	for _, current := range pkgs {
		for _, dep := range current.info.Dependencies {
			if idx, found := matchPackage(dep, pkgs); found != nil {
				current.res.Dependencies = append(current.res.Dependencies, found)
				found.Parents = append(found.Parents, current.res)
				isParented[idx] = true
			} else {
				// Could collect errors.
				// For now, early exit on error.
				err = fmt.Errorf("unable to find dependency for package %s: %v", current.info.Purl, dep)
				return
			}
		}
	}

	roots = make([]*SbomPackage, 0)
	for idx, hasParent := range isParented {
		if !hasParent {
			roots = append(roots, pkgs[idx].res)
		}
	}

	return
}

type genPkg struct {
	info *SbomPackageDependencies
	res  *SbomPackage
	id   *MatchableId
}

func matchPackage(toFind []Identifier, candidates []genPkg) (int, *SbomPackage) {
	toMatch := NewMatchableId(toFind)
	for idx, candidate := range candidates {
		if toMatch.IsSubsetEqual(candidate.id) {
			return idx, candidate.res
		}
	}
	return -1, nil
}
